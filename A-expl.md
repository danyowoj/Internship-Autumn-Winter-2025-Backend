Отличный вопрос! Давайте разберём программу по частям, уделяя особое внимание битовым операциям и логике алгоритма.

## Основная идея алгоритма

Мы используем **динамическое программирование с битовыми масками**, поскольку:
- Количество островов небольшое (n ≤ 20)
- Нужно отслеживать, какие острова уже посещены
- Битовые маски позволяют эффективно представлять множества островов

## Битовые операции - подробное объяснение

### 1. Что такое битовая маска?
Битовая маска - это число, где каждый бит представляет состояние одного острова:
- `1` - остров посещен
- `0` - остров не посещен

**Пример для n=4:**
```
Острова:   3  2  1  0  (индексы)
Биты:      0  0  0  1  (маска = 1) - посещен только остров 0
```

### 2. Ключевые битовые операции:

```cpp
// 1 << i - создает маску с единицей в позиции i
1 << 0 = 0001  // остров 0
1 << 1 = 0010  // остров 1  
1 << 2 = 0100  // остров 2
1 << 3 = 1000  // остров 3

// mask | (1 << i) - добавляет остров i в маску
mask = 0010 (остров 1)
mask | (1 << 2) = 0010 | 0100 = 0110 (острова 1 и 2)

// mask & (1 << i) - проверяет, посещен ли остров i
mask = 0110 (острова 1 и 2)
mask & (1 << 1) = 0110 & 0010 = 0010 ≠ 0 → остров 1 посещен
mask & (1 << 0) = 0110 & 0001 = 0000 = 0 → остров 0 не посещен
```

## Логика алгоритма шаг за шагом

### Шаг 1: Инициализация
```cpp
vector<vector<int>> dp(1 << n, vector<int>(n, -1));
dp[1 << 0][0] = v[0];
```
Создаем таблицу DP размером `2ⁿ × n`. `dp[mask][last]` хранит максимальную сумму сокровищ при посещении островов из `mask`, закончив на острове `last`.

Начальное состояние: `mask = 0001` (посещен только остров 0), `last = 0`, сумма = `v[0]`.

### Шаг 2: Основной цикл перебора
```cpp
for (int mask = 0; mask < (1 << n); mask++) {
    for (int last = 0; last < n; last++) {
        if (dp[mask][last] == -1) continue;
        
        for (int next = 0; next < n; next++) {
            if (!(mask & (1 << next)) && graph[last][next]) {
                // Переход на следующий остров
            }
        }
    }
}
```

**Логика:**
- Перебираем все возможные маски (все подмножества островов)
- Для каждой маски перебираем все возможные последние острова
- Если состояние достижимо (`dp[mask][last] ≠ -1`), пытаемся перейти на соседние непосещенные острова

### Шаг 3: Переход между состояниями
```cpp
int new_mask = mask | (1 << next);
int new_value = dp[mask][last] + v[next];
if (new_value > dp[new_mask][next]) {
    dp[new_mask][next] = new_value;
}
```

**Пример перехода:**
```
Текущее состояние:
mask = 0011 (посещены острова 0 и 1), last = 1, сумма = 40
Хотим перейти на остров 2 (есть туннель 1→2)

new_mask = 0011 | 0100 = 0111 (добавили остров 2)
new_value = 40 + v[2] = 40 + 20 = 60
```

### Шаг 4: Поиск ответа
```cpp
int ans = 0;
for (int mask = 0; mask < (1 << n); mask++) {
    for (int i = 0; i < n; i++) {
        ans = max(ans, dp[mask][i]);
    }
}
```
Ищем максимальное значение среди всех достижимых состояний.

## Пример выполнения для первого теста

**Данные:** n=4, v=[10,30,20,5], туннели: 0-1, 1-2, 2-3, 0-3

**Инициализация:**
```
dp[0001][0] = 10  // начальное состояние
```

**Итерация 1:** mask=0001, last=0
- Переход 0→1: new_mask=0011, dp[0011][1] = 10+30=40
- Переход 0→3: new_mask=1001, dp[1001][3] = 10+5=15

**Итерация 2:** mask=0011, last=1  
- Переход 1→2: new_mask=0111, dp[0111][2] = 40+20=60

**Итерация 3:** mask=0111, last=2
- Переход 2→3: new_mask=1111, dp[1111][3] = 60+5=65

**Итерация 4:** mask=1001, last=3
- Переход 3→2: new_mask=1101, dp[1101][2] = 15+20=35

**Результат:** максимальное значение = 65

## Почему это работает?

1. **Полный перебор:** Алгоритм рассматривает все возможные пути
2. **Оптимальная подструктура:** Максимальный путь до острова `i` через множество `mask` можно вычислить через предыдущие состояния
3. **Эффективность:** Битовые операции работают за O(1), общая сложность O(2ⁿ·n²) приемлема для n≤20

Алгоритм гарантированно находит оптимальное решение, перебирая все возможные маршруты, начиная с острова 0.
