# Подробное объяснение работы программы для поиска времени разрушения платформ

## Общая идея алгоритма

Программа решает задачу поиска минимального расстояния до большей платформы той же четности. Основная идея - разделить платформы на две группы (четные и нечетные индексы) и для каждой группы независимо найти ближайший больший элемент справа.

## Детальное объяснение по шагам

### 1. Чтение входных данных

```cpp
int n;
cin >> n;
vector<int> h(n);
for (int i = 0; i < n; i++) {
    cin >> h[i];
}
```

Просто считываем количество платформ `n` и их высоты в массив `h`.

### 2. Разделение платформ по четности индексов

```cpp
vector<int> even, odd;
for (int i = 0; i < n; i++) {
    if (i % 2 == 0) {
        even.push_back(h[i]);
    } else {
        odd.push_back(h[i]);
    }
}
```

Создаем два отдельных массива:
- `even` - содержит высоты платформ с четными индексами (0, 2, 4, ...)
- `odd` - содержит высоты платформ с нечетными индексами (1, 3, 5, ...)

**Пример для входа `[5, 3, 8, 1, 7, 9]`:**
- `even = [5, 8, 7]` (индексы 0, 2, 4)
- `odd = [3, 1, 9]` (индексы 1, 3, 5)

### 3. Алгоритм поиска следующего большего элемента

```cpp
auto findNextGreater = [](const vector<int> &arr) -> vector<int> {
    int m = arr.size();
    vector<int> nextGreater(m, -1);
    stack<int> st; // стек для хранения индексов

    // Проходим справа налево
    for (int i = m - 1; i >= 0; i--) {
        // Удаляем из стека все элементы, которые меньше или равны текущему
        while (!st.empty() && arr[st.top()] <= arr[i]) {
            st.pop();
        }
        // Если стек не пуст, следующий больший элемент найден
        if (!st.empty()) {
            nextGreater[i] = st.top();
        }
        // Добавляем текущий индекс в стек
        st.push(i);
    }
    return nextGreater;
};
```

Это классический алгоритм с использованием стека для поиска следующего большего элемента.

**Как работает стек:**
- Стек всегда содержит индексы элементов в порядке убывания их значений
- При обработке нового элемента, мы удаляем из стека все элементы, которые меньше или равны текущему
- Если после этого стек не пуст, то элемент на вершине - это ближайший больший элемент справа

**Визуализация для массива `even = [5, 8, 7]`:**

| Шаг | i | arr[i] | Стек (индексы) | Действия | nextGreater |
|-----|---|--------|----------------|----------|-------------|
| 1 | 2 | 7 | [] | Стек пуст → nextGreater[2] = -1 | [-1, -1, -1] |
|     |   |        | [2] | Добавляем 2 в стек | |
| 2 | 1 | 8 | [2] | 7 ≤ 8? Да → удаляем 2 | |
|     |   |        | [] | Стек пуст → nextGreater[1] = -1 | [-1, -1, -1] |
|     |   |        | [1] | Добавляем 1 в стек | |
| 3 | 0 | 5 | [1] | 8 > 5? Да → nextGreater[0] = 1 | [1, -1, -1] |
|     |   |        | [1, 0] | Добавляем 0 в стек | |

### 4. Применение алгоритма к обоим массивам

```cpp
vector<int> nextEven = findNextGreater(even);
vector<int> nextOdd = findNextGreater(odd);
```

Вызываем функцию для обоих массивов и получаем:
- `nextEven = [1, -1, -1]` для `even = [5, 8, 7]`
- `nextOdd = [2, 2, -1]` для `odd = [3, 1, 9]`

### 5. Формирование результата

```cpp
vector<int> res(n);
for (int i = 0; i < n; i++) {
    if (i % 2 == 0) {
        int k = i / 2; // индекс в массиве even
        if (nextEven[k] != -1) {
            res[i] = 2 * (nextEven[k] - k);
        } else {
            res[i] = -1;
        }
    } else {
        int k = i / 2; // индекс в массиве odd
        if (nextOdd[k] != -1) {
            res[i] = 2 * (nextOdd[k] - k);
        } else {
            res[i] = -1;
        }
    }
}
```

**Ключевой момент преобразования индексов:**

Поскольку мы разделили исходный массив на два, индексы в подмассивах соответствуют исходным индексам следующим образом:

- Для четных индексов: `k = i / 2`
- Для нечетных индексов: `k = i / 2`

Расстояние между платформами в исходном массиве вычисляется как `2 * (разница_индексов_в_подмассиве)`, потому что в исходном массиве индексы идут через один.

**Пример расчета для i = 0:**
- i = 0 (четный) → k = 0
- nextEven[0] = 1 → это индекс в массиве even
- Исходный индекс j = 2 × 1 = 2
- Время разрушения = j - i = 2 - 0 = 2
- Альтернативно: 2 × (1 - 0) = 2

**Пример расчета для i = 1:**
- i = 1 (нечетный) → k = 0
- nextOdd[0] = 2 → это индекс в массиве odd
- Исходный индекс j = 2 × 2 + 1 = 5
- Время разрушения = j - i = 5 - 1 = 4
- Альтернативно: 2 × (2 - 0) = 4

### 6. Вывод результата

```cpp
for (int i = 0; i < n; i++) {
    cout << res[i] << " ";
}
```

Выводим полученные времена разрушения для всех платформ.

## Анализ сложности

- **Время:** O(N) - каждый элемент добавляется и удаляется из стека не более одного раза
- **Память:** O(N) - для хранения стеков и вспомогательных массивов

## Корректность алгоритма

Алгоритм корректен потому что:
1. Разделение по четности гарантирует, что мы сравниваем только платформы одинаковой четности
2. Алгоритм со стеком гарантирует нахождение ближайшего большего элемента справа
3. Преобразование индексов корректно учитывает структуру исходного массива

Программа эффективно решает задачу, используя оптимальные по времени и памяти методы.
